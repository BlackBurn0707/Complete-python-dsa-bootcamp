## Python Operator Overloading: Customizing Operator Behavior

Operator overloading is a concept in Object-Oriented Programming (OOP) that allows you to define how standard operators (like `+`, `-`, `*`, `==`, `<`, `>`) behave when applied to instances of your custom classes. It's achieved by implementing special magic methods (dunder methods) within your class.

Essentially, it lets you provide a specific, custom implementation for an operator that works with your objects, making your code more intuitive and readable.

-----

### **1. What is Operator Overloading?**

  * **Custom Behavior:** You can define what an operator does when used with your custom objects. For example, what does `object1 + object2` mean in the context of your class?
  * **Magic Methods:** Operator overloading is implemented by defining specific magic methods (e.g., `__add__` for `+`, `__sub__` for `-`, `__eq__` for `==`).
  * **Intuitive Code:** It allows your custom objects to interact with operators in a way that feels natural and consistent with built-in data types.

-----

### **2. Common Magic Methods for Operator Overloading**

| Operator | Magic Method        | Description                                  |
| :------- | :------------------ | :------------------------------------------- |
| `+`      | `__add__(self, other)` | Addition                                     |
| `-`      | `__sub__(self, other)` | Subtraction                                  |
| `*`      | `__mul__(self, other)` | Multiplication                               |
| `/`      | `__truediv__(self, other)` | Division (true division, returns float)      |
| `//`     | `__floordiv__(self, other)` | Floor division                               |
| `%`      | `__mod__(self, other)` | Modulo                                       |
| `**`     | `__pow__(self, other)` | Exponentiation                               |
| `==`     | `__eq__(self, other)`  | Equality comparison (`self == other`)        |
| `!=`     | `__ne__(self, other)`  | Inequality comparison (`self != other`)      |
| `<`      | `__lt__(self, other)`  | Less than (`self < other`)                   |
| `<=`     | `__le__(self, other)`  | Less than or equal to (`self <= other`)      |
| `>`      | `__gt__(self, other)`  | Greater than (`self > other`)                |
| `>=`     | `__ge__(self, other)`  | Greater than or equal to (`self >= other`)   |
| `[]`     | `__getitem__(self, key)` | Indexing (e.g., `obj[key]`)                  |
| `len()`  | `__len__(self)`     | Length of object (e.g., `len(obj)`)          |

-----

### **3. Example: Overloading Operators for a `Vector` Class**

Let's consider a `Vector` class that represents a 2D vector (x, y coordinates). We'll overload operators to perform vector addition, subtraction, scalar multiplication, and equality comparison.

```python
class Vector:
    """
    A class to represent a 2D vector (x, y coordinates).
    Demonstrates operator overloading for arithmetic and comparison.
    """
    def __init__(self, x, y):
        """Initializes the vector with x and y components."""
        self.x = x
        self.y = y

    def __add__(self, other):
        """
        Overloads the '+' operator for Vector addition.
        Returns a new Vector object representing the sum of two vectors.
        (self.x + other.x, self.y + other.y)
        """
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        else:
            raise TypeError("Unsupported operand type for +: 'Vector' and '{}'".format(type(other).__name__))

    def __sub__(self, other):
        """
        Overloads the '-' operator for Vector subtraction.
        Returns a new Vector object representing the difference of two vectors.
        (self.x - other.x, self.y - other.y)
        """
        if isinstance(other, Vector):
            return Vector(self.x - other.x, self.y - other.y)
        else:
            raise TypeError("Unsupported operand type for -: 'Vector' and '{}'".format(type(other).__name__))

    def __mul__(self, scalar):
        """
        Overloads the '*' operator for scalar multiplication.
        Multiplies both components of the vector by a scalar.
        (self.x * scalar, self.y * scalar)
        """
        if isinstance(scalar, (int, float)):
            return Vector(self.x * scalar, self.y * scalar)
        else:
            raise TypeError("Unsupported operand type for *: 'Vector' and '{}'".format(type(scalar).__name__))

    def __eq__(self, other):
        """
        Overloads the '==' operator for Vector equality comparison.
        Returns True if both x and y components are equal.
        """
        if isinstance(other, Vector):
            return self.x == other.x and self.y == other.y
        return False # Not equal if comparing with a non-Vector object

    def __repr__(self):
        """
        Defines the 'official' string representation for debugging.
        """
        return f"Vector({self.x}, {self.y})"

    def __str__(self):
        """
        Defines the user-friendly string representation.
        """
        return f"({self.x}, {self.y})"


# --- Demonstration ---
v1 = Vector(2, 3)
v2 = Vector(4, 5)

print(f"Vector 1: {v1}")
print(f"Vector 2: {v2}")

# Vector Addition (uses __add__)
v_sum = v1 + v2
print(f"v1 + v2 = {v_sum}") # Output: v1 + v2 = (6, 8)

# Vector Subtraction (uses __sub__)
v_diff = v1 - v2
print(f"v1 - v2 = {v_diff}") # Output: v1 - v2 = (-2, -2)

# Scalar Multiplication (uses __mul__)
v_scaled = v1 * 3
print(f"v1 * 3 = {v_scaled}") # Output: v1 * 3 = (6, 9)

# Equality Comparison (uses __eq__)
v3 = Vector(2, 3)
print(f"v1 == v2: {v1 == v2}") # Output: v1 == v2: False
print(f"v1 == v3: {v1 == v3}") # Output: v1 == v3: True
print(f"v1 == 'abc': {v1 == 'abc'}") # Output: v1 == 'abc': False (handled by __eq__)

```

-----

### **4. Assignment: Overloading for Complex Numbers**

As an assignment, consider creating a `ComplexNumber` class and overloading operators like `+`, `-`, `*`, `/`, and `==` for complex number arithmetic.

A complex number typically has a real part and an imaginary part (e.g., $a + bi$).

**Example Structure for `ComplexNumber`:**

```python
import math

class ComplexNumber:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    def __add__(self, other):
        # (a + bi) + (c + di) = (a+c) + (b+d)i
        return ComplexNumber(self.real + other.real, self.imag + other.imag)

    def __sub__(self, other):
        # (a + bi) - (c + di) = (a-c) + (b-d)i
        return ComplexNumber(self.real - other.real, self.imag - other.imag)

    def __mul__(self, other):
        # (a + bi)(c + di) = (ac - bd) + (ad + bc)i
        new_real = self.real * other.real - self.imag * other.imag
        new_imag = self.real * other.imag + self.imag * other.real
        return ComplexNumber(new_real, new_imag)

    def __truediv__(self, other):
        # (a + bi) / (c + di) = (ac + bd)/(c^2 + d^2) + (bc - ad)/(c^2 + d^2)i
        denominator = other.real**2 + other.imag**2
        if denominator == 0:
            raise ZeroDivisionError("Cannot divide by zero (complex number denominator is zero).")
        new_real = (self.real * other.real + self.imag * other.imag) / denominator
        new_imag = (self.imag * other.real - self.real * other.imag) / denominator
        return ComplexNumber(new_real, new_imag)

    def __eq__(self, other):
        return self.real == other.real and self.imag == other.imag

    def __repr__(self):
        return f"ComplexNumber({self.real}, {self.imag})"

    def __str__(self):
        if self.imag >= 0:
            return f"{self.real} + {self.imag}i"
        else:
            return f"{self.real} - {abs(self.imag)}i"

# Example Usage:
# c1 = ComplexNumber(2, 3) # 2 + 3i
# c2 = ComplexNumber(1, -2) # 1 - 2i

# print(f"c1 + c2 = {c1 + c2}") # Expected: 3 + 1i
# print(f"c1 - c2 = {c1 - c2}") # Expected: 1 + 5i
# print(f"c1 * c2 = {c1 * c2}") # Expected: 8 - 1i
# print(f"c1 / c2 = {c1 / c2}") # Expected: -0.8 + 1.4i
# print(f"c1 == c2: {c1 == c2}") # Expected: False
```

-----

### **Conclusion:**

Magic methods and operator overloading are powerful features in Python that allow you to:

  * **Customize Object Behavior:** Define how your custom objects interact with built-in operators and functions.
  * **Enhance Readability:** Make your code more intuitive and consistent with Python's natural syntax.
  * **Improve Code Expressiveness:** Express complex operations on your objects in a concise and familiar way.

By effectively using operator overloading, you can create classes that are not only functional but also elegantly integrated into the Python language.