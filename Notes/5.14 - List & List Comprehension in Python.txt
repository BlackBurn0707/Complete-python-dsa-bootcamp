The lecture initiates the discussion on data structures in Python, with a primary focus on Lists. It covers list creation, item access, modification, various list methods, slicing, iteration, and list comprehension, including nested list comprehension.

Data Structures in Python: Lists
Lists are a fundamental and versatile data structure in Python.
1. Introduction to Lists
	• Definition: Lists are ordered, mutable collections of items. 
		○ Ordered: Items maintain their insertion order.
		○ Mutable: Items within a list can be changed (added, removed, modified) after the list is created.
	• Heterogeneous: Lists can contain items of different data types (integers, strings, floats, booleans, or even other lists).
	
2. Creating a List
	• Lists are defined using square brackets [].
	• Empty List: my_list = []
	• List with items: 
		○ names = ["Krish", "Jack", "Jacob"]
		○ numbers = [1, 2, 3, 4, 5]
		○ Mixed Data Types: mixed_list = [10, "Hello", 3.14, True]
		
3. Accessing List Items (Indexing)
	• List items are accessed using their index, which starts from 0 for the first element.
	• Positive Indexing: Accesses elements from the beginning. 
		○ fruits = ["Apple", "Banana", "Cherry", "Kiwi", "Guava"]
		○ fruits[0] returns "Apple" (first element).
		○ fruits[2] returns "Cherry" (third element).
	• Negative Indexing: Accesses elements from the end of the list. -1 refers to the last element, -2 to the second to last, and so on. 
		○ fruits[-1] returns "Guava" (last element).
		
4. Slicing Lists
	• Slicing allows you to extract a sub-section (a "slice") of a list. It returns a new list.
	• Syntax: list[start:stop:step] 
		○ start: (Optional) The starting index (inclusive). Default is 0.
		○ stop: (Optional) The ending index (exclusive). Default is the end of the list.
		○ step: (Optional) The step size between elements. Default is 1.
	• Examples: 
		○ numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
		○ numbers[2:5] returns [3, 4, 5] (elements from index 2 up to, but not including, index 5).
		○ numbers[5:] returns [6, 7, 8, 9, 10] (from index 5 to the end).
		○ numbers[:4] returns [1, 2, 3, 4] (from beginning up to, but not including, index 4).
		○ numbers[::2] returns [1, 3, 5, 7, 9] (all elements, with a step of 2).
		○ numbers[::-1] returns [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] (reverses the list).
		○ numbers[::-2] returns [10, 8, 6, 4, 2] (reverses the list with a step of 2).
		
5. Modifying List Items
	• Since lists are mutable, you can change individual items or slices.
	• Modifying Single Item: Assign a new value using its index. 
		○ fruits = ["Apple", "Banana", "Cherry", "Kiwi", "Guava"]
		○ fruits[1] = "Watermelon" changes "Banana" to "Watermelon".
	• Modifying a Slice: Assign a new list (or iterable) to a slice. The number of elements in the new list doesn't have to match the size of the slice being replaced. 
		○ Caution: Directly replacing a slice with a string will expand the string into individual characters. 
			§ fruits[1:3] = ["Grape", "Mango"] (replaces "Banana", "Cherry" with "Grape", "Mango")
			
6. List Methods (Common Operations)
Lists come with several built-in methods for common operations:
	• append(item): Adds item to the end of the list. 
		○ Example: fruits.append("Orange")
	• insert(index, item): Inserts item at the specified index. 
		○ Example: fruits.insert(1, "Watermelon") (inserts "Watermelon" at index 1).
	• remove(item): Removes the first occurrence of item from the list. Raises ValueError if the item is not found. 
		○ Example: fruits.remove("Banana")
	• pop(index=-1): Removes and returns the item at the given index. If no index is specified, it removes and returns the last item.1 
		○ Example: popped_fruit = fruits.pop()
	• index(item, start=0, end=len(list)): Returns the first index of the specified item. Raises ValueError if the item is not found. 
		○ Example: cherry_index = fruits.index("Cherry")
	• count(item): Returns the number of times item appears in the list. 
		○ Example: banana_count = fruits.count("Banana")
	• sort(key=None, reverse=False): Sorts the list in-place (modifies the original list). By default, it sorts in ascending order. 
		○ Example: fruits.sort()
	• reverse(): Reverses the order of elements in the list in-place. 
		○ Example: fruits.reverse()
	• clear(): Removes all items from the list, making it empty. 
		○ Example: fruits.clear()
		
7. Iterating Over Lists
You can iterate through list items using for loops.
	• Iterating by Value: 
Python

numbers = [1, 2, 3, 4, 5]
for num in numbers:
    print(num)
	• Iterating with Index (using enumerate()): enumerate() provides both the index and the item during iteration. 
Python

for index, num in enumerate(numbers):
    print(f"Index: {index}, Number: {num}")
	
8. List Comprehension
	• A concise and powerful way to create new lists based on existing iterables. It's often more readable and efficient than traditional for loops for list creation.
	• Basic Syntax: [expression for item in iterable] 
		○ Example (Squaring numbers): 
Python

squares = [x**2 for x in range(10)]
print(squares) # Output: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
	• With Conditional Logic: [expression for item in iterable if condition] 
		○ Example (Even numbers): 
Python

even_numbers = [num for num in range(10) if num % 2 == 0]
print(even_numbers) # Output: [0, 2, 4, 6, 8]
	• Nested List Comprehension: Used to create lists from nested iterables, or to generate combinations. 
		○ Syntax: [expression for item1 in iterable1 for item2 in iterable2]
		○ Example (Creating pairs): 
Python

list1 = [1, 2]
list2 = ['a', 'b']
pairs = [(i, j) for i in list1 for j in list2] # Creates tuples of pairs
print(pairs) # Output: [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]
	• With Function Calls: 
		○ Example (Calculating length of words): 
Python

words = ["hello", "world", "python"]
word_lengths = [len(word) for word in words]
print(word_lengths) # Output: [5, 5, 6]
		
9. Nested Lists
	• A list can contain other lists as its elements, forming a nested list (or a multi-dimensional list/matrix). 
		○ Example: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
		○ Accessing items in nested lists requires multiple indices: matrix[0][1] would access 2.
		
Common Errors and Best Practices
	• IndexError: Trying to access an index that is out of the list's bounds (e.g., my_list[len(my_list)]).
	• TypeError: Attempting to use list methods on non-list types or performing incompatible operations (e.g., adding a number directly to a string without conversion).
	• Modifying while Iterating: Be cautious when adding or removing items from a list while iterating over it using a for loop, as it can lead to unexpected behavior. Often, it's safer to iterate over a copy or build a new list.
	• Mutable Default Arguments: Avoid using lists as default arguments in functions, as they are mutable and can lead to unintended side effects.
	• Understanding sort() vs. sorted(): list.sort() sorts the list in-place and returns None. sorted(list) returns a new sorted list, leaving the original list unchanged.
	• List Comprehension for Readability: Use list comprehensions for simpler transformations and filtering to make code more readable and compact. For complex logic, traditional loops might be clearer.
	
Lists are incredibly versatile and are heavily used in Python for collecting and manipulating data. Mastering their creation, access methods, and comprehension techniques is fundamental for effective Python programming.
