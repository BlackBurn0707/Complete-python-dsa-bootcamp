## Python Polymorphism: Single Action, Multiple Forms

Polymorphism, meaning "many forms," is a core concept in Object-Oriented Programming (OOP) that allows objects of different classes to be treated as objects of a common superclass. It provides a way to perform a single action in different forms, depending on the type of object it's applied to.

In Python, polymorphism is primarily achieved through:

1.  **Method Overriding:** A child class providing its own implementation of a method already defined in its parent class.
2.  **Abstract Base Classes (ABCs):** Defining a common interface (methods) that derived classes *must* implement.

-----

### **1. Polymorphism through Method Overriding**

Method overriding allows a child class to provide a specific implementation for a method that is already defined in its parent class. When the method is called on an object of the child class, the child's version of the method is executed.

#### **Example: Animal Sounds**

**Base Class:** `Animal`

```python
class Animal:
    """
    Base class with a generic 'speak' method.
    """
    def speak(self):
        return "The animal makes a sound."

```

**Derived Class 1: `Dog`**

```python
class Dog(Animal): # Dog inherits from Animal
    """
    Dog class overriding the 'speak' method.
    """
    def speak(self): # Overriding the speak method
        return "Woof!"

```

**Derived Class 2: `Cat`**

```python
class Cat(Animal): # Cat inherits from Animal
    """
    Cat class overriding the 'speak' method.
    """
    def speak(self): # Overriding the speak method
        return "Meow!"

```

**Demonstration:**

```python
# Create objects of the derived classes
dog_obj = Dog()
cat_obj = Cat()

# Calling the 'speak' method on different objects
print(f"Dog says: {dog_obj.speak()}") # Output: Dog says: Woof!
print(f"Cat says: {cat_obj.speak()}") # Output: Cat says: Meow!

# --- Function demonstrating polymorphism ---
def animal_speak(animal):
    """
    A function that takes an animal object and calls its speak method.
    This demonstrates polymorphism as it works with any object that has a 'speak' method.
    """
    print(animal.speak())

animal_speak(dog_obj) # Output: Woof!
animal_speak(cat_obj) # Output: Meow!
```

In the `animal_speak` function, we pass different objects (`dog_obj`, `cat_obj`), but the same method call (`animal.speak()`) behaves differently based on the actual object's type. This is the essence of polymorphism.

-----

### **2. Polymorphism through Functions and Methods (Shape Example)**

Polymorphism can also be seen when functions or methods are designed to process objects of different types in a uniform way, relying on the objects' own implementations of a common method.

**Base Class:** `Shape`

```python
class Shape:
    """
    Base class for geometric shapes with a generic 'area' method.
    """
    def area(self):
        return "Area calculation for this figure is not defined in base class."

```

**Derived Class 1: `Rectangle`**

```python
class Rectangle(Shape): # Rectangle inherits from Shape
    """
    Rectangle class calculating its area.
    """
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self): # Overriding the area method
        return self.width * self.height

```

**Derived Class 2: `Circle`**

```python
import math # Import math for pi

class Circle(Shape): # Circle inherits from Shape
    """
    Circle class calculating its area.
    """
    def __init__(self, radius):
        self.radius = radius

    def area(self): # Overriding the area method
        return math.pi * (self.radius ** 2) # Formula: pi * r^2

```

**Demonstration:**

```python
# Create objects of the derived classes
rect = Rectangle(4, 5)
circ = Circle(3)

# --- Function demonstrating polymorphism ---
def print_area(shape_obj):
    """
    A function that takes a shape object and prints its area.
    This works polymorphically because each shape object has its own 'area' implementation.
    """
    print(f"The area is: {shape_obj.area():.2f}")

print_area(rect)  # Output: The area is: 20.00
print_area(circ)  # Output: The area is: 28.27 (approx 28.25 due to float precision and pi value)
```

Again, the `print_area` function calls `shape_obj.area()`, and the specific implementation (rectangle's area formula vs. circle's area formula) is determined at runtime based on the object's type.

-----

### **3. Polymorphism with Abstract Base Classes (ABCs)**

Abstract Base Classes (ABCs) in Python are a way to define an interface or a contract for classes. They allow you to enforce that derived classes *must* implement certain methods, promoting consistency and ensuring that objects conform to a specific behavior. This is Python's way of achieving "interfaces" similar to other programming languages.

  * **`abc` module:** Provides the necessary tools for creating ABCs.

      * `ABC`: The base class for defining abstract classes.
      * `abstractmethod`: A decorator used to declare abstract methods.

  * **Characteristics of ABCs:**

      * Cannot be instantiated directly (you cannot create an object of an abstract class).
      * Must be subclassed, and the subclasses *must* provide implementations for all abstract methods defined in the ABC. If a subclass fails to implement an abstract method, it will also become an abstract class and cannot be instantiated.

#### **Example: Vehicle Engines**

**Abstract Base Class:** `Vehicle`

```python
from abc import ABC, abstractmethod

class Vehicle(ABC): # Inherit from ABC to make it an abstract base class
    """
    An abstract base class defining a common interface for vehicles.
    It requires subclasses to implement 'start_engine'.
    """
    @abstractmethod # Decorator to mark this method as abstract
    def start_engine(self):
        """
        Abstract method: Subclasses must implement how their engine starts.
        """
        pass # Abstract methods typically have an empty body (pass)

```

**Derived Class 1: `Car`**

```python
class Car(Vehicle): # Car inherits from Vehicle (the ABC)
    """
    Concrete Car class implementing the 'start_engine' method.
    """
    def start_engine(self): # Implementation of the abstract method
        return "Car engine started with a turn of the key."

    # You can add other methods specific to Car here
    def drive_car(self):
        print("Driving the car.")

```

**Derived Class 2: `Motorcycle`**

```python
class Motorcycle(Vehicle): # Motorcycle inherits from Vehicle (the ABC)
    """
    Concrete Motorcycle class implementing the 'start_engine' method.
    """
    def start_engine(self): # Implementation of the abstract method
        return "Motorcycle engine roared to life."

    # You can add other methods specific to Motorcycle here
    def lean_into_turn(self):
        print("Leaning into the turn on the motorcycle.")

```

**Demonstration:**

```python
# Create objects of the concrete derived classes
my_car = Car()
my_motorcycle = Motorcycle()

# --- Function demonstrating polymorphism with ABCs ---
def start_any_vehicle(vehicle_obj):
    """
    A function that takes any Vehicle object (Car or Motorcycle)
    and calls its start_engine method polymorphically.
    """
    print(vehicle_obj.start_engine())

start_any_vehicle(my_car)       # Output: Car engine started with a turn of the key.
start_any_vehicle(my_motorcycle) # Output: Motorcycle engine roared to life.

# Trying to instantiate the abstract class will raise an error
# abstract_vehicle = Vehicle() # TypeError: Can't instantiate abstract class Vehicle with abstract method start_engine
```

In this example, the `Vehicle` ABC *forces* any class that inherits from it to provide its own `start_engine` implementation. This guarantees that `start_any_vehicle` can always call `start_engine` on any `Vehicle` object, knowing that the method exists and has a specific behavior for that vehicle type.

-----

### **Conclusion on Polymorphism:**

  * **Flexibility and Readability:** Allows writing code that operates on objects of different types through a common interface, making the code more flexible, readable, and easier to extend.
  * **Decoupling:** Reduces the tight coupling between parts of a program, as functions only need to know about the common interface (method signature) rather than the specific type of object.
  * **Maintainability:** When a new type is introduced, as long as it adheres to the common interface, existing polymorphic code can work with it without modification.