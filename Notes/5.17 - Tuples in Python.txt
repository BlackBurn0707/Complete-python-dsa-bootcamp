The lecture continues the discussion on Python data structures, focusing on Tuples. It covers their definition, creation, element access, operations, immutable nature, common methods, packing/unpacking, and nested tuples, all demonstrated with practical examples.

Data Structures in Python: Tuples
Tuples are another essential data structure in Python, often compared to lists due to their ordered nature.
1. Introduction to Tuples
	• Definition: Tuples are ordered collections of items that are immutable.
	• Key Characteristics: 
		○ Ordered: Items maintain their insertion order, just like lists.
		○ Immutable: This is the key difference from lists. Once a tuple is created, its elements cannot be changed (added, removed, or modified).
		○ Heterogeneous: Can contain items of different data types.
	• Why use Tuples? 
		○ Data Integrity: Guarantees that the data within the tuple will not be accidentally modified.
		○ Performance: Generally slightly faster than lists for iteration and access due to their fixed size.
		○ Use as Dictionary Keys: Because they are immutable, tuples can be used as keys in dictionaries (unlike lists).
		○ Function Arguments/Return Values: Often used for returning multiple values from a function.
		
2. Creating Tuples
	• Tuples are defined using parentheses ().
	• Empty Tuple: 
		○ empty_tuple = ()
		○ empty_tuple_2 = tuple() (using the tuple() constructor)
	• Tuple with items: 
		○ numbers_tuple = (1, 2, 3, 4, 5, 6)
		○ mixed_tuple = (1, "hello", 3.14, True)
	• Single-Element Tuple: To create a tuple with a single element, you must include a comma after the element; otherwise, it's treated as a normal value in parentheses. 
		○ single_element_tuple = (1,) (correct)
		○ not_a_tuple = (1) (incorrect, this is just an integer 1)
	• Type Conversion: You can convert other iterables (like lists) to tuples and vice-versa using tuple() and list() constructors. 
		○ list_to_tuple = tuple([1, 2, 3])
		○ tuple_to_list = list((1, 2, 3))
		
3. Accessing Tuple Elements (Indexing & Slicing)
	• Accessing elements in tuples works identically to lists, using zero-based indexing and slicing.
	• Indexing: 
		○ my_tuple = (10, 20, 30, 40)
		○ my_tuple[0] returns 10
		○ my_tuple[-1] returns 40 (last element)
	• Slicing: Returns a new tuple containing the specified range of elements. 
		○ my_tuple[1:3] returns (20, 30)
		○ my_tuple[2:] returns (30, 40)
		○ my_tuple[::-1] returns (40, 30, 20, 10) (reversed tuple)
		
4. Tuple Operations
	• Tuples support operations like concatenation and repetition, similar to strings and lists.
	• Concatenation (+): Combines two or more tuples into a new tuple. 
		○ tuple1 = (1, 2, 3)
		○ tuple2 = ('a', 'b')
		○ concatenated_tuple = tuple1 + tuple2 returns (1, 2, 3, 'a', 'b')
	• Repetition (*): Repeats the tuple elements a specified number of times. 
		○ repeated_tuple = tuple1 * 3 returns (1, 2, 3, 1, 2, 3, 1, 2, 3)
		
5. Immutable Nature of Tuples
	• This is the defining characteristic of tuples. Once created, you cannot directly change, add, or remove elements.
	• Attempting to modify an element will result in a TypeError. 
		○ my_tuple = (10, 20, 30)
		○ my_tuple[0] = 5 (This will cause a TypeError: 'tuple' object does not support item assignment)
	• Workaround for Modification: If you need to "modify" a tuple, you must convert it to a list, make changes, and then convert it back to a tuple. 
Python

my_tuple = (1, 2, 3)
my_list = list(my_tuple)
my_list[0] = 100
new_tuple = tuple(my_list)
print(new_tuple) # Output: (100, 2, 3)

6. Common Tuple Methods
Tuples have fewer methods than lists due to their immutability.
	• count(value): Returns the number of times a specified value appears in the tuple. 
		○ my_tuple = (1, 2, 2, 3, 1)
		○ my_tuple.count(1) returns 2
	• index(value, start=0, stop=len(tuple)): Returns the first index of the specified value. Raises a ValueError if the value is not found. 
		○ my_tuple.index(2) returns 1 (first occurrence of 2 is at index 1)
		
7. Packing and Unpacking Tuples
	• Tuple Packing: Assigning multiple values to a single variable, which Python automatically "packs" into a tuple. 
		○ packed_tuple = 1, "hello", 3.14 (parentheses are optional for packing)
		○ print(packed_tuple) will be (1, 'hello', 3.14)
	• Tuple Unpacking: Assigning elements of a tuple to multiple variables in a single statement. The number of variables must match the number of elements in the tuple. 
		○ a, b, c = packed_tuple
		○ print(a) gives 1, print(b) gives 'hello', print(c) gives 3.14
	• Unpacking with * (Star Operator): Used to "catch" multiple values into a list. This is useful when the number of elements to unpack is unknown or varies. 
		○ first, *middle, last = (1, 2, 3, 4, 5, 6)
		○ print(first) gives 1
		○ print(middle) gives [2, 3, 4, 5] (a list of remaining elements)
		○ print(last) gives 6
		
8. Nested Tuples
	• A tuple can contain other tuples as its elements, forming a nested structure. 
		○ nested_tuple = ((1, 2, 3), ('a', 'b', 'c'), (True, False))
	• Accessing Nested Elements: Use multiple indices to access elements within nested tuples. 
		○ nested_tuple[0] returns (1, 2, 3)
		○ nested_tuple[1][2] returns 'c' (element at index 2 of the tuple at index 1)
	• Iterating Over Nested Tuples: You can use nested loops to traverse elements in nested tuples. 
Python

for sub_tuple in nested_tuple:
    for item in sub_tuple:
        print(item, end=' ')
    print() # New line after each sub-tuple

9. Common Errors and Best Practices
	• TypeError: 'tuple' object does not support item assignment: The most common error, indicating an attempt to modify an immutable tuple.
	• Unpacking Mismatch: ValueError: not enough values to unpack or too many values to unpack occurs if the number of variables does not match the number of elements in the tuple during unpacking (unless * is used).
	• Creating Single-Element Tuples: Forgetting the trailing comma for single-element tuples (e.g., (item)) will result in a non-tuple type.
	• When to use Tuples vs. Lists: 
		○ Use tuples when the order of elements matters, the collection is fixed, and you want to ensure data integrity (e.g., coordinates, record-like data).
		○ Use lists when the collection needs to be mutable (elements can be added, removed, or changed frequently).

Conclusion:
Tuples are valuable in Python for creating ordered, immutable collections of items. Their immutability is a key feature, making them suitable for scenarios where data integrity is paramount, such as function arguments, dictionary keys, or fixed data records. Understanding how to leverage tuples effectively, especially with packing and unpacking, enhances the efficiency and readability of your Python code.
