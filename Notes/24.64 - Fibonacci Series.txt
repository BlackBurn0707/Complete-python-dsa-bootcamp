### **Topic: The Fibonacci Series**

The Fibonacci series is a sequence of numbers where each number is the sum of the two preceding ones. It's a classic example used to illustrate recursion.

**The Series:**
`1, 1, 2, 3, 5, 8, 13, ...`
(Note: Some definitions start with 0, but the principle is the same. Here, we start with 1.)

  * `2 = 1 + 1`
  * `3 = 1 + 2`
  * `5 = 2 + 3`

**The Recurrence Relation:**
The problem can be defined by the following recurrence relation:
`Fib(n) = Fib(n-1) + Fib(n-2)`

-----

### **The Challenge: Two Recursive Calls**

Unlike previous problems, the Fibonacci relation depends on **two** smaller instances of the same problem (`n-1` and `n-2`). This requires a stronger version of the Principle of Mathematical Induction (PMI) to justify our "leap of faith."

#### **Extended Form of PMI**

1.  **Base Case:** Same as before. Prove the statement is true for an initial value (e.g., `f(0)` or `f(1)`).
2.  **Induction Hypothesis (The Change):** Instead of just assuming the statement is true for `k`, we can **assume it is true for all values from `0` up to `k`**.
3.  **Induction Step:** Use the assumptions from Step 2 to prove the statement is true for `k+1`.

**Why does this work?**
Because you prove the base case `f(0)`, you can then use it to prove `f(1)`. Now that you know `f(0)` and `f(1)` are true, you can use them to prove `f(2)`, and so on. This step-by-step validation means that to solve for any `n`, you can safely assume that the function works correctly for all values smaller than `n`.

**The Consequence for Fibonacci:**
This extended form of PMI gives us the power to **assume that both `Fib(n-1)` and `Fib(n-2)` will return the correct answer**, allowing us to confidently write the code.

-----

### **Coding the Fibonacci Function**

#### **The Initial Flaw: A Single Base Case**

If we only provide one base case (e.g., for `n=0`), the code will fail.

```python
# FLAWED CODE
def fibonacci(n):
    if n == 0:
        return 1
    
    last = fibonacci(n - 1)
    second_last = fibonacci(n - 2) # This will cause an error for n=1
    return last + second_last
```

This leads to a `RecursionError` because a call like `fibonacci(1)` would attempt to call `fibonacci(-1)`, leading to an infinite loop of negative numbers.

#### **The Key Insight: Two Base Cases are Required**

Since the Fibonacci series depends on the **two** preceding numbers, its recursive implementation logically requires **two base cases** to start the sequence correctly.

**Corrected Code:**

```python
def fibonacci(n):
    # Base Case 1
    if n == 0:
        return 1
    # Base Case 2
    if n == 1:
        return 1
    
    # Recursive Step using the "leap of faith" for both calls
    last = fibonacci(n - 1)
    second_last = fibonacci(n - 2)
    
    return last + second_last

# Example: Find the 4th Fibonacci number (using 0-based indexing for the series 1, 1, 2, 3, 5...)
# Fib(0)=1, Fib(1)=1, Fib(2)=2, Fib(3)=3, Fib(4)=5
print(f"The 4th Fibonacci number is: {fibonacci(4)}")
```

**Output:**

```
The 4th Fibonacci number is: 5
```

-----